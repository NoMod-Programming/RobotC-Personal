#pragma config(Sensor, dgtl1,  bumper,         sensorTouch)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motor3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           motor4,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           servo,         tmotorServoStandard, openLoop)
#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int timewait = 0;
bool running = true;
string credits1 = "By Crow, Bridge,";
string credits2 = "& AA. To /zero.";
// Code Refactoring by Wolf


/*
7 = Controls initial modes l=1,U=2,R=3, then 8 to change mode, leave it alone for ~10 sec, setting 1

*/

// You may ask why this is an int... This is because this will allow for error reporting as shown below:
/*
  if (errorcondition) {
    return 5
  }
*/

int mode1()
{
  motor[motor2] = vexRT[Ch3];
	motor[motor1] = vexRT[Ch2];
	motor[motor4] = vexRT[Ch3Xmtr2];
	motor[motor3] = vexRT[Ch2Xmtr2];
	return 0;
}

int mode2()
{
	motor[motor3] = vexRT[Ch3];
	motor[motor4] = vexRT[Ch3];
	motor[motor1] = vexRT[Ch2];
	motor[motor2] = vexRT[Ch2];
}

int mode3()
{
	motor[motor2] = vexRT[Ch3];
	motor[motor1] = vexRT[Ch2];
	motor[motor3] = vexRT[Ch3Xmtr2];
	motor[motor4] = vexRT[Ch3Xmtr2];
}

task main()
{
	ClearTimer(T1); // Why weren't timers used in the first place? You can clean up so many kludges with this...
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDPos(0, 0);
	displayNextLCDString(credits1);
	displayLCDPos(1, 0);
	displayNextLCDString(credits2);
	while(running == true) {
		while(timewait < 333333) {
			if(vexRT[Btn7L] == 1) {
				timewait = 1000000;
			} else if(vexRT[Btn7U] == 1) {
				timewait = 2000000;
			} else if(vexRT[Btn7R] == 1) {
				timewait = 3000000;
			}
			timewait++;
		}
		if(timewait == 333333) {
			motor[servo] = 70;
			wait1Msec(500);
			motor[servo] = 0;
			while(true) {
        mode1()
				if(vexRT[Btn8U] == 1) {
					timewait = 2000000;
					break;
				} else if(vexRT[Btn8R] == 1) {
					timewait = 3000000;
					break;
				} else if(SensorValue[bumper] == 1) {
					running = false;
					break;
				}
			}
		} else if(timewait >= 1000000 && timewait <= 1000100) {
			motor[servo] = 70;
			wait1Msec(500);
			motor[servo] = 0;
			while(true) {
        mode1()
				if(vexRT[Btn8U] == 1) {
					timewait = 2000000;
					break;
				} else if(vexRT[Btn8R] == 1) {
					timewait = 3000000;
					break;
				} else if(SensorValue[bumper] == 1) {
					running = false;
					break;
				}
			}
		} else if(timewait >= 2000000 && timewait <= 2000100) {
			motor[servo] = 70;
			wait1Msec(1000);
			motor[servo] = 0;
			while(true) {
				mode2()
				if(vexRT[Btn8L] == 1) {
					timewait = 1000000;
					break;
				}	else if(vexRT[Btn8R] == 1) {
					timewait = 3000000;
					break;
				}	else if(SensorValue[bumper] == 1)	{
					running = false;
					break;
				}
			}
		} else if(timewait >= 3000000 && timewait <= 3000100) {
			motor[servo] = 70;
			wait1Msec(1500);
			motor[servo] = 0;
			while(true) {
				mode3()
				if(vexRT[Btn8L] == 1)	{
					timewait = 1000000;
					break;
				}	else if(vexRT[Btn8U] == 1) {
					timewait = 2000000;
					break;
				} else if(SensorValue[bumper] == 1)	{
					running = false;
					break;
				}
			}
		}
	}
	motor[motor1] = 0;
	motor[motor2] = 0;
	motor[motor3] = 0;
	motor[motor4] = 0;
	while(true) {
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0, 0);
		displayNextLCDString(credits1);
		displayLCDPos(1, 0);
		displayNextLCDString(credits2);
	}
}
